import {
  makeContractDeploy,
  broadcastTransaction,
  AnchorMode,
  PostConditionMode,
  makeRandomPrivKey,
  getAddressFromPrivateKey,
} from '@stacks/transactions';
import { STACKS_TESTNET, STACKS_MAINNET } from '@stacks/network';
import type { StacksNetwork } from '@stacks/network';

export interface ContractData {
  eventName: string;
  eventDate: string;
  eventTime?: string;
  venue?: string;
  description?: string;
  category: string;
  royaltyPercentage: string;
  ticketCategories: Array<{
    id: string;
    name: string;
    price: string;
    supply: string;
    description: string;
  }>;
  totalSupply: number;
  totalRevenue: number;
  deployer: string;
  totalCost: number;
  metadataUri?: string;
  template: string;
}

export class StacksDeploymentService {
  private network: StacksNetwork;
  private isTestnet: boolean;

  constructor(isTestnet: boolean = true) {
    // Force testnet for now
    this.isTestnet = true;
    
    // Use official network objects from @stacks/network
    this.network = STACKS_TESTNET;
    
    console.log('üåê Stacks Network configured:', {
      network: 'TESTNET (forced)',
      chainId: '0x' + this.network.chainId.toString(16),
      transactionVersion: '0x' + this.network.transactionVersion.toString(16),
    });
  }

  /**
   * Generate Clarity contract code for NFT ticketing (SIP-009 Compliant)
   */
  generateContractCode(contractData: ContractData): string {
    const { eventName, eventDate, eventTime, venue, ticketCategories, totalSupply, metadataUri, royaltyPercentage } = contractData;

    // Use first category for main pricing, or default
    const mainCategory = ticketCategories[0];
    const ticketPriceInMicroSTX = Math.floor((parseFloat(mainCategory?.price || '0.001')) * 1000000);
    const royaltyBasisPoints = Math.floor((parseFloat(royaltyPercentage) || 5) * 100); // Convert to basis points

    return `
;; NFT Ticket Event Contract - SIP-009 Compliant
;; Generated by Pulse Robot Platform
;; Event: ${eventName}
;; Date: ${eventDate} ${eventTime || ''}
;; Generated on: ${new Date().toISOString()}

(define-non-fungible-token event-ticket uint)

;; Constants
(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-token-owner (err u101))
(define-constant err-sold-out (err u102))
(define-constant err-invalid-price (err u103))
(define-constant err-not-authorized (err u104))
(define-constant err-ticket-used (err u105))
(define-constant err-not-found (err u106))

;; Data Variables
(define-data-var last-token-id uint u0)
(define-data-var ticket-price uint u${ticketPriceInMicroSTX})
(define-data-var max-supply uint u${totalSupply})
(define-data-var base-uri (string-ascii 256) "${metadataUri || 'ipfs://placeholder/'}")
(define-data-var is-sale-active bool true)
(define-data-var royalty-percent uint u${royaltyBasisPoints})

;; Event details
(define-data-var event-name (string-utf8 256) u"${eventName}")
(define-data-var event-date (string-utf8 64) u"${eventDate}")
(define-data-var event-time (string-utf8 32) u"${eventTime || 'TBA'}")
(define-data-var event-venue (string-utf8 256) u"${venue || 'TBA'}")

;; Ticket Data Maps
(define-map tickets uint {
  owner: principal,
  tier: (string-utf8 32),
  purchase-price: uint,
  purchase-date: uint,
  is-used: bool,
  seat-number: (optional (string-utf8 32))
})

;; Marketplace listings
(define-map listings uint {
  price: uint,
  seller: principal
})

;; ============================================
;; SIP-009 Standard Functions
;; ============================================

(define-read-only (get-last-token-id)
  (ok (var-get last-token-id)))

(define-read-only (get-token-uri (token-id uint))
  (if (is-some (map-get? tickets token-id))
    (ok (some (var-get base-uri)))
    err-not-found))

(define-read-only (get-owner (token-id uint))
  (ok (nft-get-owner? event-ticket token-id)))

(define-public (transfer (token-id uint) (sender principal) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender sender) err-not-token-owner)
    (let ((ticket (unwrap! (map-get? tickets token-id) err-not-found)))
      (asserts! (not (get is-used ticket)) err-ticket-used)
      (try! (nft-transfer? event-ticket token-id sender recipient))
      (map-set tickets token-id (merge ticket { owner: recipient }))
      (ok true))))

;; ============================================
;; Ticket Minting Functions
;; ============================================

(define-public (mint-ticket (tier (string-utf8 32)) (seat (optional (string-utf8 32))))
  (let (
    (token-id (+ (var-get last-token-id) u1))
    (current-time (unwrap-panic (get-block-info? time (- block-height u1))))
  )
    ;; Validations
    (asserts! (var-get is-sale-active) err-not-authorized)
    (asserts! (< (var-get last-token-id) (var-get max-supply)) err-sold-out)

    ;; Transfer STX payment to contract owner
    (try! (stx-transfer? (var-get ticket-price) tx-sender contract-owner))

    ;; Mint NFT
    (try! (nft-mint? event-ticket token-id tx-sender))

    ;; Store ticket data
    (map-set tickets token-id {
      owner: tx-sender,
      tier: tier,
      purchase-price: (var-get ticket-price),
      purchase-date: current-time,
      is-used: false,
      seat-number: seat
    })

    ;; Update counter
    (var-set last-token-id token-id)
    (ok token-id)))

;; Admin mint (no payment required)
(define-public (admin-mint (recipient principal) (tier (string-utf8 32)))
  (let (
    (token-id (+ (var-get last-token-id) u1))
    (current-time (unwrap-panic (get-block-info? time (- block-height u1))))
  )
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    (asserts! (< (var-get last-token-id) (var-get max-supply)) err-sold-out)

    (try! (nft-mint? event-ticket token-id recipient))

    (map-set tickets token-id {
      owner: recipient,
      tier: tier,
      purchase-price: u0,
      purchase-date: current-time,
      is-used: false,
      seat-number: none
    })

    (var-set last-token-id token-id)
    (ok token-id)))

;; ============================================
;; Ticket Usage
;; ============================================

(define-public (use-ticket (token-id uint))
  (let ((ticket (unwrap! (map-get? tickets token-id) err-not-found)))
    (asserts! (is-eq (some tx-sender) (nft-get-owner? event-ticket token-id)) err-not-token-owner)
    (asserts! (not (get is-used ticket)) err-ticket-used)
    (map-set tickets token-id (merge ticket { is-used: true }))
    (ok true)))

;; ============================================
;; Secondary Market
;; ============================================

(define-public (list-ticket (token-id uint) (price uint))
  (let ((ticket (unwrap! (map-get? tickets token-id) err-not-found)))
    (asserts! (is-eq (some tx-sender) (nft-get-owner? event-ticket token-id)) err-not-token-owner)
    (asserts! (> price u0) err-invalid-price)
    (asserts! (not (get is-used ticket)) err-ticket-used)
    (map-set listings token-id { price: price, seller: tx-sender })
    (ok true)))

(define-public (unlist-ticket (token-id uint))
  (begin
    (asserts! (is-eq (some tx-sender) (nft-get-owner? event-ticket token-id)) err-not-token-owner)
    (map-delete listings token-id)
    (ok true)))

(define-public (buy-listed-ticket (token-id uint))
  (let (
    (listing (unwrap! (map-get? listings token-id) err-not-found))
    (ticket (unwrap! (map-get? tickets token-id) err-not-found))
    (seller (get seller listing))
    (price (get price listing))
    (royalty-amount (/ (* price (var-get royalty-percent)) u10000))
    (seller-amount (- price royalty-amount))
  )
    (asserts! (not (get is-used ticket)) err-ticket-used)
    ;; Pay seller
    (try! (stx-transfer? seller-amount tx-sender seller))
    ;; Pay royalty to contract owner
    (try! (stx-transfer? royalty-amount tx-sender contract-owner))
    ;; Transfer NFT
    (try! (transfer token-id seller tx-sender))
    ;; Remove listing
    (map-delete listings token-id)
    (ok true)))

;; ============================================
;; Admin Functions
;; ============================================

(define-public (set-base-uri (new-base-uri (string-ascii 256)))
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    (var-set base-uri new-base-uri)
    (ok true)))

(define-public (set-ticket-price (new-price uint))
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    (var-set ticket-price new-price)
    (ok true)))

(define-public (toggle-sale)
  (begin
    (asserts! (is-eq tx-sender contract-owner) err-owner-only)
    (var-set is-sale-active (not (var-get is-sale-active)))
    (ok (var-get is-sale-active))))

;; ============================================
;; Read-Only Functions
;; ============================================

(define-read-only (get-event-info)
  (ok {
    name: (var-get event-name),
    date: (var-get event-date),
    time: (var-get event-time),
    venue: (var-get event-venue),
    ticket-price: (var-get ticket-price),
    max-supply: (var-get max-supply),
    tickets-sold: (var-get last-token-id),
    available: (- (var-get max-supply) (var-get last-token-id)),
    sale-active: (var-get is-sale-active),
    royalty-percent: (var-get royalty-percent)
  }))

(define-read-only (get-ticket-info (token-id uint))
  (ok (map-get? tickets token-id)))

(define-read-only (get-listing (token-id uint))
  (ok (map-get? listings token-id)))

(define-read-only (get-ticket-price)
  (ok (var-get ticket-price)))

(define-read-only (get-tickets-sold)
  (ok (var-get last-token-id)))

(define-read-only (get-available-tickets)
  (ok (- (var-get max-supply) (var-get last-token-id))))

(define-read-only (is-sale-active)
  (ok (var-get is-sale-active)))

(define-read-only (get-contract-uri)
  (ok (some (var-get base-uri))))
`;
  }

  /**
   * Deploy contract to Stacks network - REAL DEPLOYMENT
   * Broadcasts transaction to Stacks Testnet/Mainnet
   */
  async deployContract(contractData: ContractData, privateKey: string): Promise<{
    txId: string;
    contractName: string;
    contractAddress: string;
    transaction: any;
    network: string;
    explorerUrl: string;
    apiStatusUrl: string;
  }> {
    try {
      if (!privateKey) {
        throw new Error('Private key is required for deployment');
      }

      // Generate contract code
      const contractCode = this.generateContractCode(contractData);

      // Generate unique contract name (shorter to avoid length limits)
      const timestamp = Date.now().toString(36);
      const random = Math.random().toString(36).substring(2, 6);
      const contractName = `pulse-${timestamp}-${random}`;

      // Get sender address
      const senderAddress = getAddressFromPrivateKey(privateKey, this.network);

      console.log('üöÄ Deploying contract to Stacks blockchain:', {
        contractName,
        senderAddress,
        network: this.isTestnet ? 'testnet' : 'mainnet',
        eventName: contractData.eventName,
        codeSize: contractCode.length
      });

      // Create contract deploy transaction using network string
      // v7.x accepts 'testnet' | 'mainnet' | 'devnet' | 'mocknet' as string
      const txOptions = {
        contractName,
        codeBody: contractCode,
        senderKey: privateKey,
        network: 'testnet' as const,  // Use const assertion for literal type
        anchorMode: AnchorMode.Any,
        postConditionMode: PostConditionMode.Allow,
        fee: 200000, // 0.2 STX fee for contract deployment
      };

      console.log('üìù Creating contract deploy transaction...');
      const transaction = await makeContractDeploy(txOptions);
      
      console.log('‚úÖ Transaction created:', {
        txType: transaction.payload?.payloadType,
        auth: transaction.auth?.authType,
        fee: transaction.auth?.spendingCondition?.fee?.toString(),
      });

      console.log('üì° Broadcasting transaction to network...');
      console.log('Network details:', {
        isTestnet: this.isTestnet,
        chainId: this.network.chainId,
        coreApiUrl: (this.network as any).coreApiUrl,
        broadcastEndpoint: (this.network as any).getBroadcastApiUrl?.() || 'unknown'
      });

      // Use the official broadcastTransaction function from @stacks/transactions
      // In v7.x, broadcastTransaction expects an object with transaction and network
      let broadcastResponse;
      try {
        broadcastResponse = await broadcastTransaction({
          transaction,
          network: 'testnet' as const  // Use string literal for network
        });
        
        console.log('üì® Broadcast Response:', broadcastResponse);
        
      } catch (broadcastError: any) {
        console.error('‚ùå Broadcast failed:', {
          error: broadcastError.message,
          details: broadcastError,
          stack: broadcastError.stack
        });
        throw new Error(`Failed to broadcast transaction: ${broadcastError.message}`);
      }

      // Validate we got a txid back
      if (!broadcastResponse || !broadcastResponse.txid) {
        console.error('‚ùå Invalid broadcast response:', broadcastResponse);
        throw new Error('Broadcast did not return a transaction ID');
      }
      
      const txId = broadcastResponse.txid;
      const contractAddress = `${senderAddress}.${contractName}`;

      // Get the correct explorer URL and API URL for status checking
      const networkName = this.isTestnet ? 'testnet' : 'mainnet';
      const apiBaseUrl = this.isTestnet ? 'https://api.testnet.hiro.so' : 'https://api.hiro.so';
      const explorerUrl = `https://explorer.hiro.so/txid/${txId}?chain=${networkName}`;
      
      // Immediately verify transaction was received by checking API
      console.log('üîç Verifying transaction was received...');
      try {
        const verifyResponse = await fetch(`${apiBaseUrl}/extended/v1/tx/${txId}`);
        if (verifyResponse.ok) {
          const txData = await verifyResponse.json();
          console.log('‚úÖ Transaction verified in network:', txData.tx_status);
        } else if (verifyResponse.status === 404) {
          console.warn('‚ö†Ô∏è  Transaction not found immediately (this may be normal for first few seconds)');
        } else {
          console.warn('‚ö†Ô∏è  Could not verify transaction:', verifyResponse.status);
        }
      } catch (verifyError) {
        console.warn('‚ö†Ô∏è  Verification check failed:', verifyError);
      }

      console.log('‚úÖ Contract deployed successfully:', {
        txId,
        contractAddress,
        contractName,
        network: networkName,
        explorerUrl,
        apiStatusUrl: `${apiBaseUrl}/extended/v1/tx/${txId}`,
        eventName: contractData.eventName,
        totalSupply: contractData.totalSupply,
        note: 'Transaction is pending. Check explorer in 2-5 minutes.'
      });

      // Log instructions for user
      console.log(`
üîç Transaction Status Check:
- Explorer: ${explorerUrl}
- API Status: ${apiBaseUrl}/extended/v1/tx/${txId}
- Contract Address: ${contractAddress}

‚è≥ Please wait 2-5 minutes for transaction to be confirmed on ${networkName}.
The transaction needs to be:
1. Received by mempool
2. Included in a block
3. Confirmed by the network

You can refresh the explorer page to see updates.
      `);

      return {
        txId,
        contractName,
        contractAddress,
        transaction,
        network: networkName,
        explorerUrl,
        apiStatusUrl: `${apiBaseUrl}/extended/v1/tx/${txId}`
      };

    } catch (error: any) {
      console.error('‚ùå Contract deployment error:', error);
      
      // Provide more detailed error messages
      if (error.message?.includes('NotEnoughFunds')) {
        throw new Error('Insufficient STX balance for deployment. You need at least 0.2 STX.');
      } else if (error.message?.includes('ConflictingNonceInMempool')) {
        throw new Error('Previous transaction still pending. Please wait a moment and try again.');
      } else if (error.message?.includes('BadNonce')) {
        throw new Error('Transaction nonce error. Please refresh and try again.');
      }
      
      throw new Error(`Failed to deploy contract: ${error.message}`);
    }
  }

  /**
   * Generate a random private key for demo purposes
   */
  private generateRandomPrivateKey(): string {
    const randomBytes = new Uint8Array(32);
    crypto.getRandomValues(randomBytes);
    return '0x' + Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Estimate deployment cost
   */
  async estimateDeploymentCost(contractData: ContractData): Promise<number> {
    try {
      const contractCode = this.generateContractCode(contractData);

      // Base cost calculation (simplified)
      const baseCost = 100000; // 0.1 STX base fee
      const codeSizeCost = contractCode.length * 10; // Additional cost based on code size

      return baseCost + codeSizeCost;
    } catch (error) {
      console.error('Error estimating deployment cost:', error);
      return 100000; // Fallback to base cost
    }
  }

  /**
   * Get contract info from deployed contract
   */
  async getContractInfo(contractAddress: string): Promise<any> {
    try {
      const apiUrl = this.isTestnet
        ? 'https://api.testnet.hiro.so'
        : 'https://api.hiro.so';

      const response = await fetch(
        `${apiUrl}/v2/contracts/interface/${contractAddress}`
      );

      if (response.ok) {
        return await response.json();
      } else {
        throw new Error(`Failed to fetch contract info: ${response.statusText}`);
      }
    } catch (error: any) {
      console.error('Error fetching contract info:', error);
      throw new Error(`Failed to get contract info: ${error.message}`);
    }
  }

  /**
   * Check transaction status on the blockchain
   * Returns the current status of a transaction
   */
  async checkTransactionStatus(txId: string): Promise<{
    status: 'pending' | 'success' | 'failed' | 'not_found';
    tx_status: string;
    tx_result?: any;
    block_height?: number;
    burn_block_time?: number;
    error?: string;
  }> {
    try {
      const apiBaseUrl = this.isTestnet 
        ? 'https://api.testnet.hiro.so' 
        : 'https://api.hiro.so';
      
      const response = await fetch(`${apiBaseUrl}/extended/v1/tx/${txId}`);
      
      if (!response.ok) {
        if (response.status === 404) {
          return {
            status: 'not_found',
            tx_status: 'Transaction not found yet. It may still be propagating.',
            error: 'Transaction not found in API. Wait a few seconds and try again.'
          };
        }
        throw new Error(`API Error: ${response.status}`);
      }

      const txData = await response.json();
      
      // Map Stacks API status to our simplified status
      let status: 'pending' | 'success' | 'failed' | 'not_found' = 'pending';
      
      if (txData.tx_status === 'success') {
        status = 'success';
      } else if (txData.tx_status === 'abort_by_response' || txData.tx_status === 'abort_by_post_condition') {
        status = 'failed';
      } else if (txData.tx_status === 'pending') {
        status = 'pending';
      }

      return {
        status,
        tx_status: txData.tx_status,
        tx_result: txData.tx_result,
        block_height: txData.block_height,
        burn_block_time: txData.burn_block_time,
      };
    } catch (error: any) {
      console.error('Error checking transaction status:', error);
      return {
        status: 'not_found',
        tx_status: 'error',
        error: error.message
      };
    }
  }

  /**
   * Wait for transaction to be confirmed
   * Polls the API until transaction is no longer pending
   */
  async waitForTransactionConfirmation(
    txId: string, 
    options: {
      maxAttempts?: number;
      intervalMs?: number;
      onStatusUpdate?: (status: any) => void;
    } = {}
  ): Promise<any> {
    const { 
      maxAttempts = 30,  // 30 attempts 
      intervalMs = 10000, // 10 seconds between checks
      onStatusUpdate 
    } = options;

    console.log(`‚è≥ Waiting for transaction ${txId} to confirm...`);
    console.log(`Will check every ${intervalMs/1000} seconds, max ${maxAttempts} attempts`);

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const status = await this.checkTransactionStatus(txId);
      
      if (onStatusUpdate) {
        onStatusUpdate(status);
      }

      console.log(`Attempt ${attempt}/${maxAttempts}: ${status.tx_status}`);

      if (status.status === 'success') {
        console.log('‚úÖ Transaction confirmed!');
        return status;
      }

      if (status.status === 'failed') {
        throw new Error(`Transaction failed: ${status.tx_result || 'Unknown error'}`);
      }

      if (attempt < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, intervalMs));
      }
    }

    throw new Error('Transaction confirmation timeout. Please check explorer manually.');
  }
}

// Export singleton instance
export const stacksDeploymentService = new StacksDeploymentService(true); // Use testnet